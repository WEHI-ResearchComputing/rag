<h2>Your Shell Environment</h2><p>When you connect to Milton via SSH (Secure SHell), an environment is setup for you with some preset "environment variables". Environment variables affect how programs run when you execute them inside your shell. For example, the PATH environment variable controls which commands are available to use. On this page, we'll show you how to:</p><ul><li>use environment variables,</li><li>important and useful environment variables,</li><li>how to automatically setup your environment using the <em>.bashrc file, and</em></li><li>using aliases and functions.</li></ul><p>If you have any questions or need any help with the material on this page, please contact the <a href="mailto:research.computing@wehi.edu.au" data-cke-saved-href="mailto:research.computing@wehi.edu.au" data-interception="off" title="mailto:research.computing@wehi.edu.au" target="_blank">Research Computing Platform Team</a>.</p>
<h3><span class="fontColorThemeSecondary">Using Environment Variables</span></h3><p>An important distinction to make is the difference between <em>shell variables</em> and <em>environment variables</em>. Shell variables are declared like so:</p><pre>$ VARX=1\n</pre><p>and if we want to refer to that variable, we prefix the variable name with the "$" symbol:</p><pre>$ echo $VARX\n1\n</pre><p>However, if we make a script that looks like below</p><pre>$ cat varscript.sh\n#!/bin/bash\necho "x = $VARX"</pre><p>and we run the script:</p><pre>$ ./varscript.sh\nx =\n</pre><p>it doesn't echo $VARX like if we ran it from the command line. But if we <em>export</em> the variable to our environment like so:</p><pre>$ export VARX</pre><p>and then run it again:</p><pre>$ ./varscript.sh\nx = 1\n</pre><p>the script echos our saved variable!</p><p>In summary, the distinction between a shell variable and an environment variable, is that programs that you run inside your shell can also see the variable. To list which environment variables are set in your shell, use the <em>env</em> command:</p><pre>$ env\nMANPATH=:/usr/local/slurm/current/share/man\nXDG_SESSION_ID=797400\nHOSTNAME=slurm-login01.hpc.wehi.edu.au\nTERM=linux\nSHELL=/bin/bash\n... truncated output ...\nLESSOPEN=||/usr/bin/lesspipe.sh %s\nXDG_RUNTIME_DIR=/run/user/5087\nBASH_FUNC_module()=() {&nbsp; eval `/usr/bin/modulecmd bash $*`\n}\n_=/usr/bin/env\n</pre><h4>Removing an environment variable</h4><p>The <em>unset</em> command will set the value of an environment variable to nothing.</p><pre>$ echo $VARX   # currently VARX is set to 1\n1\n\n$ unset VARX   # unsetting...\n\n$ echo $VARX   # VARX is gone!\n\n</pre><h4>Passing variables to programs without exporting</h4><p>In some cases, you may need to set a value of an environment variable for a program you wish to run. But you may not want this variable influencing other programs. Instead of exporting then unsetting, you can also pass the variable to the program directly:</p><pre>$ echo $VARX                 # empty\nx = \n\n$ VARX=1 ./varscript.sh      # the variable was passed\nx = 1\n\n$ echo $VARX                 # VARX still empty in your environment!\nx =\n</pre><p>Note that the variable definition occurs <em>before</em> the calling to the script. Otherwise, it will be interpreted as an argument.</p>
<h3><span class="fontColorThemeSecondary">Modifying the PATH environment variable</span></h3><p>A very important environment variable is the PATH variable, which is a colon-delimited list of multiple directories:</p><pre>$ echo $PATH\n/usr/local/slurm/current/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/stornext/Home/data/allstaff/y/yang.e/.local/bin:/stornext/Home/data/allstaff/y/yang.e/bin\n</pre><p>Your shell uses this list to search for commands and scripts to run. For example, commands like <em>cd</em> and <em>ls</em> are stored in /usr/bin. We don't have to use the whole path for commands like cd and ls because the directories they are stored in are saved in the PATH variable!</p><p>Throughout your research journey, you likely will create useful scripts or programs that you want to use regularly. With the PATH variable, you can make these easier to use. To do this, you update the PATH variable (note the colon) by:</p><pre>export PATH=/path/to/my/handy/scripts:$PATH</pre><p>So for example, if I have some scripts saved in a "handyscripts" directory in my home directory:</p><pre>$ ls ~/handyscripts\ncleandata.sh  helloworld.sh\n\n$ which helloworld.sh\n/usr/bin/which: <span class="fontColorRedDark">no helloworld.sh</span> in (/usr/local/slurm/current/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/stornext/Home/data/allstaff/y/yang.e/.local/bin:/stornext/Home/data/\nallstaff/y/yang.e/bin)\n\n$ export PATH=~/handyscripts:$PATH\n\n$ which helloworld.sh\n~/handyscripts/helloworld.sh\n\n$ helloworld.sh\nhello world!\n</pre><p>By adding ~/handyscripts to my PATH environment variable, I made the helloworld.sh script available anywhere. Note that a script/program has to have the "executable" attribute for the shell to be able to run it.</p><h4>Precedence in PATH</h4><p>Your shell searches through the PATH environment sequentially and uses the first script/program it finds matching the command name. For example, if I have a PATH variable like</p><pre>$ echo $PATH\n/my/cooler/bin:/usr/bin\n</pre><p>the shell will search through /my/cooler/bin before /usr/bin. if I have a "find" program in both directories:</p><pre>$ echo $PATH   # only /usr/bin in my PATH\n/usr/bin\n\n$ which find\n/usr/bin/find\n\n$ export /my/cooler/bin:$PATH  # adding my directory to my PATH\n\n$ which find   # my shell chose /my/cooler/bin/find!\n/my/cooler/bin/find\n</pre><p>This way, you can "override" system commands in favour of yours.</p><h4>Setting environment variables with scripts</h4><p>If you have a script with environment variables being set, you must <em>source</em> the script for the environment variables to be exported into your environment.</p><pre>$ cat setup-env-script.sh\n#!/bin/bash\nexport VARX=1\nexport VARX=2\n\n$ echo "x = $VARX y = $VARY"\nx =  y = \n\n$ source setup-env-script.sh\n\n$ echo "x = $VARX y = $VARY"\nx = 1 y = \n</pre>
<h3><span class="fontColorThemePrimary">Important or Useful Environment Variables</span></h3><h4>LD_LIBRARY_PATH</h4><p>Is used by "linker" programs to link programs to libraries it needs to run. It is also used when compiling software. If you are <a href="/sites/rc2/SitePages/Installing-software.aspx" data-cke-saved-href="https://wehieduau.sharepoint.com/sites/rc2/SitePages/Installing-software.aspx" data-interception="on" title="https://wehieduau.sharepoint.com/sites/rc2/SitePages/Installing-software.aspx">installing your own software</a>, you will sometimes need to use this. It works like PATH in that it is a comma-delimited list of directories which will be searched.</p><h4>PYTHONPATH</h4><p>This is a Python-specific environment variable. This variable is used by Python to search for modules to import. This could be useful to modify if you have useful Python functions that you have not converted into an installable package. Inside Python, it corresponds to the sys.path variable.</p><h4>R_LIBS</h4><p>This is a R-specific environment variable. R uses this variable to locate where to install or find R packages. This is very useful for maintaining different versions of packages.<br></p>
<p>Each program may use their own environment variables to control its behaviour. So, make sure to check which environment variables are important to your software!</p>
<h3><span class="fontColorThemeSecondary">Using the .bashrc File to Setup Your Environment</span></h3><p>When you set environment variables, you will probably notice that they disappear if you disconnect or exit from your shell. This is because every time you log out and then back in, the shell sets up your environment from scratch using a few different files. One of these files is the <span class="fontColorBlue"><strong><em>.bashrc</em> file</strong></span> in your home directory. Note the "." in the filename, which means the file is hidden from <em>ls</em> by default. To see the file with<em> ls</em>, use <em>ls -a</em>. When you first start on Milton, your <em>.bashrc</em> file should like very similar to</p><pre>$ cat ~/.bashrc\n# .bashrc\n[ -z "$PS1" ] &amp;&amp; return\n\n# Source global definitions\nif [ -f /etc/bashrc ]; then\n. /etc/bashrc\nfi\n\n# Uncomment the following line if you don't like systemctl's auto-paging feature:\n# export SYSTEMD_PAGER=\n\n# User specific aliases and functions\n\n# Detect OS:\n\n# If OS is CentOS:\nif [ -f /etc/redhat-release ]; then\n        centosVersion=`cat /etc/redhat-release | sed  "s/[^0-9.]//g"  | cut -d. -f1`\n# If OS is Ubuntu\nelif [ `lsb_release -i | awk '{print $3;}'` == "Ubuntu" ]; then\n        test -f &amp;&amp; . .bashrc_ubuntu\nfi</pre><p>the <em>.bashrc</em> file can be modified to set environment variables every time you login via ssh. To do so, you edit the file to include an export command for the environment variable you would like to be set every time you ssh onto Milton. For example, I could setup the PATH to include the<em>&nbsp;handyscripts</em>&nbsp;directory used in the previous example</p><pre>$ cat ~/.bashrc \n# .bashrc \n[ -z "$PS1" ] &amp;&amp; return # Source global definitions \nif [ -f /etc/bashrc ]; then \n. /etc/bashrc \nfi \n\n# Uncomment the following line if you don't like systemctl's auto-paging feature: \n# export SYSTEMD_PAGER= \n\n# User specific aliases and functions \n\n# Detect OS: \n\n# If OS is CentOS: \nif [ -f /etc/redhat-release ]; then \n        centosVersion=`cat /etc/redhat-release | sed "s/[^0-9.]//g" | cut -d. -f1` \n# If OS is Ubuntu \nelif [ `lsb_release -i | awk '{print $3;}'` == "Ubuntu" ]; then \n        test -f &amp;&amp; . .bashrc_ubuntu \nfi\n\n<strong><span class="fontColorThemeSecondary">export PATH=~/handyscripts:$PATH</span></strong>\n</pre><p>This results in the <em>handyscripts</em> directory being included in my path every time I ssh onto Milton.</p><p>You can use the <em>.bashrc</em> to prepare your environment in any way at login time. For example, loading software modules that you use frequently, activating a conda or python virtual environment, or reminding you of your filesystem quotas!</p><p>If you accidentally remove your <em>.bashrc</em> file, please contact <a href="mailto:support@wehi.edu.au" data-cke-saved-href="mailto:support@wehi.edu.au" data-interception="off" title="mailto:support@wehi.edu.au" target="_blank">helpdesk</a>.</p>
<h3><span class="fontColorThemePrimary">Setting Aliases</span></h3><p>Aliases can be used to save long and difficult-to-remember commands in a more compact form for easier use. Aliases are created with the <em>alias</em> command:</p><pre>alias squ="squeue -u $USER"</pre><p>this creates the <em>squ</em> alias which shows the status of pending/running jobs in the Slurm queue, but just for the active user. Like environment variables, aliases persist only until you exit the shell, but can also be saved in the <em>.bashrc</em> file.</p><p>To view currently set aliases:</p><pre>alias -p</pre><p><br></p>
<h3><span class="fontColorThemePrimary">Creating Functions</span></h3><p>Functions are similar to aliases, but more flexible as they can better manipulate arguments and include control logic which aliases cannot. An example of a function:</p><pre>$ middle ()\n&gt; {\n&gt;     head -n $2 $3 | tail $1\n&gt; }\n</pre><p>which creates the "middle" function. The function has three arguments referenced by $N, like in a bash script.</p><p>Like environment variables and scripts, functions can be defined in <em>.bashrc</em> to be defined every time you ssh onto Milton.</p>
<ul><li><strong>aliases</strong> are for frequently used single statements with limited input</li><li><strong>functions</strong> are for frequently used collection of statements that may need varied input arguments</li><li><strong>scripts</strong> should be used if the work process needs to be recorded, preserved, or shared. It is also better suited to integrating with software outside of the current shell.</li><li>In scripts, avoid using aliases or functions defined elsewhere as it's less reproducible</li></ul>
